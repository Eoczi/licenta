<html>
  <head>
    <meta http-equiv="cache-control" content="no-cache, must-revalidate, post-check=0, pre-check=0" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="pragma" content="no-cache" />    
    <title>SavorSim</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.js"></script>
    <script>
      delete AFRAME.components["grabbable"];
    </script>
    <script src="https://unpkg.com/aframe-event-set-component@4.2.1/dist/aframe-event-set-component.min.js"></script>
    <script src="https://unpkg.com/super-hands@^3.0.4/dist/super-hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@v4.2.2/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/aframe-physics-extras/dist/aframe-physics-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>
    <script src="https://rawgit.com/caseyyee/aframe-ui-widgets/master/dist/aframe-ui-widgets.min.js"></script>
    <script src="https://unpkg.com/aframe-template-component@3.2.1/dist/aframe-template-component.min.js"></script>
    <script src="https://unpkg.com/aframe-gltf-part-component/dist/aframe-gltf-part-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-particle-system-component@1.1.4/dist/aframe-particle-system-component.min.js"></script>    
    <script>
      AFRAME.registerComponent('add-body', {
        schema: {
          bodyType: { default: 'static', oneOf: ['static', 'dynamic'] },
          shape: {default: 'auto', oneOf: ['auto', 'box', 'cylinder', 'sphere', 'hull', 'mesh', 'none']},
        },

        init: function() {
          var el = this.el;
          var bodyType = this.data.bodyType;
          var shape = this.data.shape;
          
          el.addEventListener('model-loaded', function (event) {
            if (bodyType == 'static') {
              el.setAttribute('static-body', 'shape: ' + shape);
            } else if (bodyType == 'dynamic') {
              el.setAttribute('dynamic-body', 'shape: ' + shape);
            }
          });
          
        }
      });

      AFRAME.registerComponent('change-scene', {
        schema: {
          scene: { type: 'string', oneOf: ['scene1', 'scene2']},
        },

        init: function () {
          var el = this.el;
          var sceneSelector = document.getElementById('scene-selector');
          var path = 'src/scenes/' + this.data.scene + '.html';
          el.addEventListener('pressed', function () {
            sceneSelector.setAttribute('template', 'src', path);
          });
        }
      });

      AFRAME.registerComponent('knob-turn', {
        schema: {
          burner: {type: 'string', oneOf: ['#burner0', '#burner1', '#burner2', '#burner3']}
        },

        init: function () {
          var el = this.el;
          var burner = document.getElementById(this.data.burner);
          var target = document.getElementById("#target");

          el.addEventListener('change', function (event) {
            var value = event.detail.value * 360 * Math.PI;
            
            el.setAttribute('rotation', {
              y: (el.getAttribute('rotation').y + value) % 360
            });
            if (el.getAttribute('rotation').y > 0 && el.getAttribute('rotation').y <= 90){
              
              burner.setAttribute('animation', {
                property: 'color',
                from: el.getAttribute('color'),
                to: '#880000',
                dur: 2000
              });
            }
            else if (el.getAttribute('rotation').y > 90 && el.getAttribute('rotation').y <= 180) {
              burner.setAttribute('animation', {
                property: 'color',
                from: el.getAttribute('color'),
                to: '#FF0000',
                dur: 2000
              });
            }
            else {
              burner.setAttribute('animation', {
                property: 'color',
                from: el.getAttribute('color'),
                to: '#000000',
                dur: 2000
              });
            }
          });
        }
      });
      AFRAME.registerComponent('cannon-body', {

        init: function () {
          var el= this.el;

          el.addEventListener('body-loaded', function (event) {
            var body = event.detail.body;
            var id = body.el.id;
            if (id == '#instruction') {
              var boxShape = new CANNON.Box(new CANNON.Vec3(0.01, 0.63, 0.5));
              body.shapes = [boxShape];
              body.shapeOffsets = [new CANNON.Vec3(0, 0, 0)];
            }
            else if (id == "#plate") {
              console.log("helol");
            }
          });
        }
      })

      AFRAME.registerComponent('change-slides', {

        init: function () {
          var el= this.el;
          var frame = document.getElementById("#frame");
          var img = document.getElementsByTagName('img');
          el.addEventListener('change', function (event) {
            var value = event.detail.value;
            if (value < 0) {
              value = Math.max(value, 0.01);
            }
            else if (value > 0) {
              value = Math.min(value, 3.99);
            }
            frame.setAttribute('src', '#' + img[Math.trunc(value)].id);
          });
        }
      })

      AFRAME.registerComponent('plating', {

        init: function () {
          this.el.isFinished = 0;
        },
        
        tick: function(time, timeDelta) {
          var el= this.el;
          var offset = 0.05;
          var body = el.body;
          var foods = document.getElementsByClassName("food");
          var ok = 0;
          

          if (foods.length != 0 && el.isFinished == 0) {
            var sandwichHeight = 0.3;
            var plateGeometry = el.getAttribute('geometry');
            for (var i = 0; i < foods.length; i++) {
              var platePos = el.getAttribute('position');
              var foodPos = foods[i].body.position;

              const deltaX = foodPos.x - platePos.x;
              const deltaY = foodPos.y - platePos.y;
              const deltaZ = foodPos.z - platePos.z;

              if (Math.abs(deltaX) < plateGeometry.width/2 && Math.abs(deltaY) < sandwichHeight && Math.abs(deltaZ) < plateGeometry.depth/2) {
                foods[i].classList.add("sandwich");
                sandwichHeight += deltaY;
              }
              else if (foods[i].classList.contains("sandwich")) {
                foods[i].classList.remove("sandwich");
              }
            }
            el.sandwichParts = document.getElementsByClassName("sandwich");
            var sandwichParts = el.sandwichParts;

            function sortByYPosition(collection) {
              return Array.from(collection).sort((entityA, entityB) => {
                const posA = entityA.body.position.y;
                const posB = entityB.body.position.y;
                return posA - posB;
              });
            }
            if (sandwichParts.length > 1) {
              sandwichParts = sortByYPosition(sandwichParts);
            }
            document.getElementsByTagName
            if (  
              sandwichParts.length > 3 && 
              sandwichParts[0].classList.contains("bread") && 
              sandwichParts[sandwichParts.length-1].classList.contains("bread")
            ) {
              var plate = document.getElementById("#plate");
              plate.setAttribute('particle-system', 
                'preset: default; size: 0.2; sizeSpread: 0.5; direction: 0.3; accelerationValue: 0 1 0; accelerationSpread: 1 1 1; velocityValue: 0 2 0; velocitySpread: 0 2 0;'
              )
              el.isFinished = 1;
              el.startTimer = time
            }
          }
          else if (el.isFinished == 1 && time - el.startTimer > 3000) {
            var sceneSelector = document.getElementById("scene-selector");
            sceneSelector.setAttribute("template", "src: src/scenes/scene_selector.html");
          }

          
        },
      })

      AFRAME.registerComponent('cuttable', {
        schema: {
          geometry: {type: 'string', oneOf: ['sphere', 'box', 'cylinder']}
        },

        init: function() {
          var el = this.el;
          el.collided = 3;
          el.startTimer = 0;
          if (this.data.geometry == 'box') {
            el.widthOffset = el.firstElementChild.getAttribute('geometry').width;
          }
          else if (this.data.geometry == 'sphere') {
            el.widthOffset = el.firstElementChild.getAttribute('radius') / el.children.length + 0.1;
          }
          else if (this.data.geometry == 'cylinder') {
            var cylinder = el.children[1];
            el.widthOffset = cylinder.getAttribute('geometry').height;
          }

          el.addEventListener('collide', function collision(event) {
            var collidedEntity = event.detail.body.el;
            if (el.collided == 3 && collidedEntity.id == "#knife") {
              el.collided = 0;
              el.removeEventListener('collide', collision);
            }
            
          });
        },

        tick: function(time, timeDelta) {
          var el = this.el;
          var sceneEl = document.getElementById("scene-selector");
          var cutEntity = el.firstElementChild;
          var cutEntityCopy = cutEntity.cloneNode(false);
          var shapeEls = el.children;

          switch (el.collided) {
            case 0:
              var newPos = { x: el.body.position.x + el.widthOffset * shapeEls.length / 2 + 0.05, y: el.body.position.y + 0.05 , z: el.body.position.z}
              el.removeChild(cutEntity);
              cutEntityCopy.object3D.quaternion.copy(el.body.quaternion);
              cutEntityCopy.setAttribute('position', newPos);
              cutEntityCopy.setAttribute('dynamic-body', "shape: box; mass: 5");
              cutEntityCopy.setAttribute("class", cutEntityCopy.getAttribute("class") + " food");
              cutEntityCopy.setAttribute("base", cutEntity.getAttribute("base"));
              sceneEl.appendChild(cutEntityCopy);
              
              if (shapeEls.length == 0) {
                el.parentNode.removeChild(el);
                break;
              }

              el.removeAttribute('dynamic-body');
              el.removeAttribute('body-merger');
              el.collided = 1;
              break;
            case 1:
              if (this.data.geometry !== 'sphere') {
                for (var i = 0; i < shapeEls.length; i++) {
                  var shape = shapeEls[i];
                  var align;
                  if (this.data.geometry === 'box') {
                    align = -((shapeEls.length - 1) * el.widthOffset) / 2 + i * el.widthOffset;
                    shape.setAttribute('position', {x: align, y: 0, z: 0});
                  }
                  else {
                    align = -((shapeEls.length - 1) * el.widthOffset) / 2 + i * el.widthOffset;
                    if (i == shapeEls.length - 1) {
                      align = align - el.widthOffset / 2;
                      shape.setAttribute('rotation', '0 0 180');
                    }
                    shape.setAttribute('position', {x: 0, y: align, z: 0});
                  }
                }
              }
              
              el.setAttribute('dynamic-body', { shape: 'box', mass: 5});
              el.setAttribute('body-merger');

              el.startTimer = time;
              el.collided = 2;
              break;
            case 2:
              if (time - el.startTimer > 2000 && el.startTimer != 0) {
                el.addEventListener('collide', function collision(event) {
                  var collidedEntity = event.detail.body.el;
                  
                  if (el.collided == 3 && collidedEntity.id == "#knife") {

                    el.collided = 0;
                    el.removeEventListener('collide', collision);
                  }
                });
                el.collided = 3;
                el.startTimer = 0;
              }
              break;
          }
        }
      });

      AFRAME.registerComponent('base', {
        schema: {
          place: {type: 'string', oneOf: ['top', 'bottom', 'both']},
          color: {type: 'string', default: 'white'}
        },
        
        init: function () {
          var el = this.el;
          var geometry = el.getAttribute('geometry');
          if (this.data.place == 'bottom' || this.data.place == 'both') {
            var bottomCircle = document.createElement('a-circle');
            var bottomRadius; 
            var bottomYPosition;
            if (geometry.primitive == 'sphere') {
              var radiusSphere = geometry.radius;
              var thetaStart = geometry.thetaStart;
              var thetaLength = geometry.thetaLength;
              var theta = thetaStart + thetaLength;
              var thetaBottom = (thetaStart + thetaLength) * Math.PI / 180;
              bottomRadius = radiusSphere * Math.sin(thetaBottom);
              bottomYPosition = -radiusSphere * Math.cos(thetaBottom);
              bottomCircle.setAttribute("material", 'side: double');
              bottomCircle.setAttribute("geometry", { radius: bottomRadius });
              bottomCircle.setAttribute("position", {x: 0, y: -bottomYPosition, z: 0});
              bottomCircle.setAttribute("rotation", '90 0 0');
              bottomCircle.setAttribute("class", "bottom");
              bottomCircle.setAttribute('color', this.data.color);
              el.appendChild(bottomCircle);
            }
            else if (geometry.primitive == 'cylinder') {
              bottomRadius = geometry.radius;
              bottomYPosition = geometry.height / 2 + 0.001;
              bottomCircle.setAttribute("material", 'side: double');
              bottomCircle.setAttribute("geometry", { radius: bottomRadius });
              bottomCircle.setAttribute("position", { x: 0, y: -bottomYPosition, z: 0 });
              bottomCircle.setAttribute("rotation", '90 0 0');
              bottomCircle.setAttribute("class", "bottom");
              bottomCircle.setAttribute('color', this.data.color);
              el.appendChild(bottomCircle);
            }
            else if (geometry.primitive == 'box') {
              var bottomPlane = document.createElement('a-plane');
              var planeWidth = geometry.depth;
              var planeHeight = geometry.height;
              bottomXPosition = geometry.width / 2 + 0.001;
              bottomPlane.setAttribute("geometry", { width: planeWidth, height: planeHeight });
              bottomPlane.setAttribute("position", {x: -bottomXPosition, y: 0, z: 0});
              bottomPlane.setAttribute('rotation', '0 90 0');
              bottomPlane.setAttribute("class", "bottom");
              bottomPlane.setAttribute('color', this.data.color);
              bottomPlane.setAttribute('material', 'side: double');
              el.appendChild(bottomPlane);
            }
            
          }
          if (this.data.place == 'top' || this.data.place == 'both') {
            var topCircle = document.createElement('a-circle');
            var topRadius;
            var topYPosition;
            if (geometry.primitive == 'sphere') {
              var radiusSphere = geometry.radius;
              var thetaStart = geometry.thetaStart;
              var thetaLength = geometry.thetaLength;
              var thetaTop = thetaStart * Math.PI / 180;
              thetaTop = thetaStart * Math.PI / 180;
              topRadius = radiusSphere * Math.sin(thetaTop);
              topYPosition = radiusSphere * Math.cos(thetaTop);
              topCircle.setAttribute('radius', topRadius);
              topCircle.setAttribute('material', 'side: double');
              topCircle.setAttribute('position', {x: 0, y: topYPosition, z: 0});
              topCircle.setAttribute('rotation', '90 0 0');
              topCircle.setAttribute("class", "top");
              topCircle.setAttribute('color', this.data.color);
              el.appendChild(topCircle);
            }
            else if (geometry.primitive == 'cylinder') {
              topRadius = geometry.radius;
              topYPosition = geometry.height / 2 + 0.001;
              topCircle.setAttribute('radius', topRadius);
              topCircle.setAttribute('material', 'side: double');
              topCircle.setAttribute('position', {x: 0, y: topYPosition, z: 0});
              topCircle.setAttribute('rotation', '90 0 0');
              topCircle.setAttribute("class", "top");
              topCircle.setAttribute('color', this.data.color);
              el.appendChild(topCircle);
            }
            else if (geometry.primitive == 'box') {
              var topPlane = document.createElement('a-plane');
              var planeWidth = geometry.depth;
              var planeHeight = geometry.height;
              topXPosition = geometry.width / 2 + 0.001;

              topPlane.setAttribute("geometry", { width: planeWidth, height: planeHeight });
              topPlane.setAttribute('position', {x: topXPosition, y: 0, z: 0});
              topPlane.setAttribute('rotation', '0 90 0');
              topPlane.setAttribute("class", "top");
              topPlane.setAttribute('color', this.data.color);
              topPlane.setAttribute('material', 'side: double');
              el.appendChild(topPlane);
            }
          }
        },
      });
      AFRAME.registerComponent('plate-geometry', {
        remove: function () {
          this.el.removeObject3D('mesh');
        },

        init: function() {
          const geometryEdge = new THREE.CylinderGeometry( 0.75, 0.55, 0.1, 8, 1, true); 
          const geometryBase = new THREE.CylinderGeometry( 0.55, 0.55, 0.01, 8);
          const materialEdge = new THREE.MeshStandardMaterial({ color: 0xffff00, side: THREE.DoubleSide });
          const cylinderEdge = new THREE.Mesh(geometryEdge, materialEdge);
          const materialBase = new THREE.MeshStandardMaterial();
          const cylinderBase = new THREE.Mesh(geometryBase, materialBase);
          cylinderBase.position.set(0, -0.05, 0);
          const group = new THREE.Group();
          group.add(cylinderBase);
          group.add(cylinderEdge);
          this.el.setObject3D('mesh', group);
          
        },
      })

      
    </script>
    
    <!--script src="./src/index.js"></script-->
  </head>
  <body>
    <a-scene physics="debug: true;">
      <a-assets>
        <a-asset-item id="knife-gltf" src="assets/models/knife2.gltf"></a-asset-item>
        <a-asset-item id="kitchen-gltf" src="assets/models/kitchen2.gltf"></a-asset-item>
        <a-asset-item id="sandwich-gltf" src="assets/models/SANDWICH_REVAMPED.gltf"></a-asset-item>

        <img id="visitor0" src="assets/images/visitor_1.png">
        <img id="visitor1" src="assets/images/visitor_2.png">
        <img id="visitor2" src="assets/images/visitor_3.png">
        <img id="visitor3" src="assets/images/visitor_4.png">

        <a-mixin id="interactable"
          class="interactable"
          hoverable grabbable draggable
          event-set__hoveron="_event: hover-start; material.opacity: 0.8; transparent: true"
          event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
        ></a-mixin>
        <a-mixin
          id="physics-hand"
          physics-collider
          collision-filter="collisionForces: false"
          static-body="shape: sphere; sphereRadius: 0.03"
          super-hands="colliderEvent: collisions;
                      colliderEventProperty: els;
                      colliderEndEvent: collisions;
                      colliderEndEventProperty: clearedEls;">
        </a-mixin>
        <a-mixin id="burner"
          geometry="primitive: cylinder; height: 0.1; radius: 1"
          material="color: black"
          scale="0.33 0.33 0.33">
        </a-mixin>
        <a-mixin id="cube"
          geometry="primitive: box; width: 0.5; height: 0.5; depth: 0.5">
        </a-mixin>
      </a-assets>

      <a-entity id="#camera-rig" position="0 0 3" rotation="0 0 0">
        <a-camera id="#head" look-controls wasd-controls>
          <a-cursor raycaster="objects: .interactable"
            fuse="true"
            fusetimeout="500"
            position="0 0 -1"
            geometry="primitive: ring; radiusInner: 0.005; radiusOuter: 0.006"
            material="color: black; shader: flat">
          </a-cursor>
        </a-camera>
        <a-entity id="#rhand" mixin="physics-hand" hand-controls="hand: right"></a-entity>
        <a-entity id="#lhand" mixin="physics-hand" hand-controls="hand: left"></a-entity>
      </a-entity>

      <a-entity id="scene-selector" template="src: src/scenes/scene_selector.html"></a-entity>
      
      <a-plane static-body rotation="90 0 0" geometry="width: 100; height: 100" scale="1000 1000 1000"></a-plane>
      <a-entity environment></a-entity>
    </a-scene>
    
  </body>
</html>